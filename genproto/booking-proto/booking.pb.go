// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: booking-proto/booking.proto

package booking

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type DelRes struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DelRes) Reset()         { *m = DelRes{} }
func (m *DelRes) String() string { return proto.CompactTextString(m) }
func (*DelRes) ProtoMessage()    {}
func (*DelRes) Descriptor() ([]byte, []int) {
	return fileDescriptor_6f4ab27959496508, []int{0}
}
func (m *DelRes) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DelRes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DelRes.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DelRes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DelRes.Merge(m, src)
}
func (m *DelRes) XXX_Size() int {
	return m.Size()
}
func (m *DelRes) XXX_DiscardUnknown() {
	xxx_messageInfo_DelRes.DiscardUnknown(m)
}

var xxx_messageInfo_DelRes proto.InternalMessageInfo

type Id struct {
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Id) Reset()         { *m = Id{} }
func (m *Id) String() string { return proto.CompactTextString(m) }
func (*Id) ProtoMessage()    {}
func (*Id) Descriptor() ([]byte, []int) {
	return fileDescriptor_6f4ab27959496508, []int{1}
}
func (m *Id) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Id) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Id.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Id) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Id.Merge(m, src)
}
func (m *Id) XXX_Size() int {
	return m.Size()
}
func (m *Id) XXX_DiscardUnknown() {
	xxx_messageInfo_Id.DiscardUnknown(m)
}

var xxx_messageInfo_Id proto.InternalMessageInfo

func (m *Id) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

type Filter struct {
	Filter               map[string]string `protobuf:"bytes,1,rep,name=filter,proto3" json:"filter" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *Filter) Reset()         { *m = Filter{} }
func (m *Filter) String() string { return proto.CompactTextString(m) }
func (*Filter) ProtoMessage()    {}
func (*Filter) Descriptor() ([]byte, []int) {
	return fileDescriptor_6f4ab27959496508, []int{2}
}
func (m *Filter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Filter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Filter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Filter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Filter.Merge(m, src)
}
func (m *Filter) XXX_Size() int {
	return m.Size()
}
func (m *Filter) XXX_DiscardUnknown() {
	xxx_messageInfo_Filter.DiscardUnknown(m)
}

var xxx_messageInfo_Filter proto.InternalMessageInfo

func (m *Filter) GetFilter() map[string]string {
	if m != nil {
		return m.Filter
	}
	return nil
}

type ListReqById struct {
	Limit                uint64   `protobuf:"varint,1,opt,name=limit,proto3" json:"limit"`
	Offset               uint64   `protobuf:"varint,2,opt,name=offset,proto3" json:"offset"`
	Id                   *Id      `protobuf:"bytes,3,opt,name=id,proto3" json:"id"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListReqById) Reset()         { *m = ListReqById{} }
func (m *ListReqById) String() string { return proto.CompactTextString(m) }
func (*ListReqById) ProtoMessage()    {}
func (*ListReqById) Descriptor() ([]byte, []int) {
	return fileDescriptor_6f4ab27959496508, []int{3}
}
func (m *ListReqById) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListReqById) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListReqById.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListReqById) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListReqById.Merge(m, src)
}
func (m *ListReqById) XXX_Size() int {
	return m.Size()
}
func (m *ListReqById) XXX_DiscardUnknown() {
	xxx_messageInfo_ListReqById.DiscardUnknown(m)
}

var xxx_messageInfo_ListReqById proto.InternalMessageInfo

func (m *ListReqById) GetLimit() uint64 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *ListReqById) GetOffset() uint64 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func (m *ListReqById) GetId() *Id {
	if m != nil {
		return m.Id
	}
	return nil
}

type ListReq struct {
	Limit                uint64   `protobuf:"varint,1,opt,name=limit,proto3" json:"limit"`
	Offset               uint64   `protobuf:"varint,2,opt,name=offset,proto3" json:"offset"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListReq) Reset()         { *m = ListReq{} }
func (m *ListReq) String() string { return proto.CompactTextString(m) }
func (*ListReq) ProtoMessage()    {}
func (*ListReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_6f4ab27959496508, []int{4}
}
func (m *ListReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListReq.Merge(m, src)
}
func (m *ListReq) XXX_Size() int {
	return m.Size()
}
func (m *ListReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ListReq.DiscardUnknown(m)
}

var xxx_messageInfo_ListReq proto.InternalMessageInfo

func (m *ListReq) GetLimit() uint64 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *ListReq) GetOffset() uint64 {
	if m != nil {
		return m.Offset
	}
	return 0
}

type ListUserHotelRes struct {
	UserHotel            []*GeneralBook `protobuf:"bytes,1,rep,name=user_hotel,json=userHotel,proto3" json:"user_hotel"`
	Count                int64          `protobuf:"varint,2,opt,name=count,proto3" json:"count"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *ListUserHotelRes) Reset()         { *m = ListUserHotelRes{} }
func (m *ListUserHotelRes) String() string { return proto.CompactTextString(m) }
func (*ListUserHotelRes) ProtoMessage()    {}
func (*ListUserHotelRes) Descriptor() ([]byte, []int) {
	return fileDescriptor_6f4ab27959496508, []int{5}
}
func (m *ListUserHotelRes) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListUserHotelRes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListUserHotelRes.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListUserHotelRes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListUserHotelRes.Merge(m, src)
}
func (m *ListUserHotelRes) XXX_Size() int {
	return m.Size()
}
func (m *ListUserHotelRes) XXX_DiscardUnknown() {
	xxx_messageInfo_ListUserHotelRes.DiscardUnknown(m)
}

var xxx_messageInfo_ListUserHotelRes proto.InternalMessageInfo

func (m *ListUserHotelRes) GetUserHotel() []*GeneralBook {
	if m != nil {
		return m.UserHotel
	}
	return nil
}

func (m *ListUserHotelRes) GetCount() int64 {
	if m != nil {
		return m.Count
	}
	return 0
}

type ListUserRestaurantRes struct {
	UserRestaurant       []*GeneralBook `protobuf:"bytes,1,rep,name=user_restaurant,json=userRestaurant,proto3" json:"user_restaurant"`
	Count                int64          `protobuf:"varint,2,opt,name=count,proto3" json:"count"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *ListUserRestaurantRes) Reset()         { *m = ListUserRestaurantRes{} }
func (m *ListUserRestaurantRes) String() string { return proto.CompactTextString(m) }
func (*ListUserRestaurantRes) ProtoMessage()    {}
func (*ListUserRestaurantRes) Descriptor() ([]byte, []int) {
	return fileDescriptor_6f4ab27959496508, []int{6}
}
func (m *ListUserRestaurantRes) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListUserRestaurantRes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListUserRestaurantRes.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListUserRestaurantRes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListUserRestaurantRes.Merge(m, src)
}
func (m *ListUserRestaurantRes) XXX_Size() int {
	return m.Size()
}
func (m *ListUserRestaurantRes) XXX_DiscardUnknown() {
	xxx_messageInfo_ListUserRestaurantRes.DiscardUnknown(m)
}

var xxx_messageInfo_ListUserRestaurantRes proto.InternalMessageInfo

func (m *ListUserRestaurantRes) GetUserRestaurant() []*GeneralBook {
	if m != nil {
		return m.UserRestaurant
	}
	return nil
}

func (m *ListUserRestaurantRes) GetCount() int64 {
	if m != nil {
		return m.Count
	}
	return 0
}

type ListUserAttractionRes struct {
	UserAttraction       []*GeneralBook `protobuf:"bytes,1,rep,name=user_attraction,json=userAttraction,proto3" json:"user_attraction"`
	Count                int64          `protobuf:"varint,2,opt,name=count,proto3" json:"count"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *ListUserAttractionRes) Reset()         { *m = ListUserAttractionRes{} }
func (m *ListUserAttractionRes) String() string { return proto.CompactTextString(m) }
func (*ListUserAttractionRes) ProtoMessage()    {}
func (*ListUserAttractionRes) Descriptor() ([]byte, []int) {
	return fileDescriptor_6f4ab27959496508, []int{7}
}
func (m *ListUserAttractionRes) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListUserAttractionRes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListUserAttractionRes.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListUserAttractionRes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListUserAttractionRes.Merge(m, src)
}
func (m *ListUserAttractionRes) XXX_Size() int {
	return m.Size()
}
func (m *ListUserAttractionRes) XXX_DiscardUnknown() {
	xxx_messageInfo_ListUserAttractionRes.DiscardUnknown(m)
}

var xxx_messageInfo_ListUserAttractionRes proto.InternalMessageInfo

func (m *ListUserAttractionRes) GetUserAttraction() []*GeneralBook {
	if m != nil {
		return m.UserAttraction
	}
	return nil
}

func (m *ListUserAttractionRes) GetCount() int64 {
	if m != nil {
		return m.Count
	}
	return 0
}

type GeneralBook struct {
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id"`
	UserId               string   `protobuf:"bytes,2,opt,name=user_id,json=userId,proto3" json:"user_id"`
	HraId                string   `protobuf:"bytes,3,opt,name=hra_id,json=hraId,proto3" json:"hra_id"`
	WillArrive           string   `protobuf:"bytes,4,opt,name=will_arrive,json=willArrive,proto3" json:"will_arrive"`
	WillLeave            string   `protobuf:"bytes,5,opt,name=will_leave,json=willLeave,proto3" json:"will_leave"`
	NumberOfPeople       int64    `protobuf:"varint,6,opt,name=number_of_people,json=numberOfPeople,proto3" json:"number_of_people"`
	IsCanceled           bool     `protobuf:"varint,7,opt,name=is_canceled,json=isCanceled,proto3" json:"is_canceled"`
	Reason               string   `protobuf:"bytes,8,opt,name=reason,proto3" json:"reason"`
	CreatedAt            string   `protobuf:"bytes,9,opt,name=created_at,json=createdAt,proto3" json:"created_at"`
	UpdatedAt            string   `protobuf:"bytes,10,opt,name=updated_at,json=updatedAt,proto3" json:"updated_at"`
	DeletedAt            string   `protobuf:"bytes,11,opt,name=deleted_at,json=deletedAt,proto3" json:"deleted_at"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GeneralBook) Reset()         { *m = GeneralBook{} }
func (m *GeneralBook) String() string { return proto.CompactTextString(m) }
func (*GeneralBook) ProtoMessage()    {}
func (*GeneralBook) Descriptor() ([]byte, []int) {
	return fileDescriptor_6f4ab27959496508, []int{8}
}
func (m *GeneralBook) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GeneralBook) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GeneralBook.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GeneralBook) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GeneralBook.Merge(m, src)
}
func (m *GeneralBook) XXX_Size() int {
	return m.Size()
}
func (m *GeneralBook) XXX_DiscardUnknown() {
	xxx_messageInfo_GeneralBook.DiscardUnknown(m)
}

var xxx_messageInfo_GeneralBook proto.InternalMessageInfo

func (m *GeneralBook) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *GeneralBook) GetUserId() string {
	if m != nil {
		return m.UserId
	}
	return ""
}

func (m *GeneralBook) GetHraId() string {
	if m != nil {
		return m.HraId
	}
	return ""
}

func (m *GeneralBook) GetWillArrive() string {
	if m != nil {
		return m.WillArrive
	}
	return ""
}

func (m *GeneralBook) GetWillLeave() string {
	if m != nil {
		return m.WillLeave
	}
	return ""
}

func (m *GeneralBook) GetNumberOfPeople() int64 {
	if m != nil {
		return m.NumberOfPeople
	}
	return 0
}

func (m *GeneralBook) GetIsCanceled() bool {
	if m != nil {
		return m.IsCanceled
	}
	return false
}

func (m *GeneralBook) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

func (m *GeneralBook) GetCreatedAt() string {
	if m != nil {
		return m.CreatedAt
	}
	return ""
}

func (m *GeneralBook) GetUpdatedAt() string {
	if m != nil {
		return m.UpdatedAt
	}
	return ""
}

func (m *GeneralBook) GetDeletedAt() string {
	if m != nil {
		return m.DeletedAt
	}
	return ""
}

type UserId struct {
	UserId               []*Id    `protobuf:"bytes,1,rep,name=user_id,json=userId,proto3" json:"user_id"`
	Count                int64    `protobuf:"varint,2,opt,name=count,proto3" json:"count"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UserId) Reset()         { *m = UserId{} }
func (m *UserId) String() string { return proto.CompactTextString(m) }
func (*UserId) ProtoMessage()    {}
func (*UserId) Descriptor() ([]byte, []int) {
	return fileDescriptor_6f4ab27959496508, []int{9}
}
func (m *UserId) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserId) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserId.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserId) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserId.Merge(m, src)
}
func (m *UserId) XXX_Size() int {
	return m.Size()
}
func (m *UserId) XXX_DiscardUnknown() {
	xxx_messageInfo_UserId.DiscardUnknown(m)
}

var xxx_messageInfo_UserId proto.InternalMessageInfo

func (m *UserId) GetUserId() []*Id {
	if m != nil {
		return m.UserId
	}
	return nil
}

func (m *UserId) GetCount() int64 {
	if m != nil {
		return m.Count
	}
	return 0
}

func init() {
	proto.RegisterType((*DelRes)(nil), "booking.DelRes")
	proto.RegisterType((*Id)(nil), "booking.Id")
	proto.RegisterType((*Filter)(nil), "booking.Filter")
	proto.RegisterMapType((map[string]string)(nil), "booking.Filter.FilterEntry")
	proto.RegisterType((*ListReqById)(nil), "booking.ListReqById")
	proto.RegisterType((*ListReq)(nil), "booking.ListReq")
	proto.RegisterType((*ListUserHotelRes)(nil), "booking.ListUserHotelRes")
	proto.RegisterType((*ListUserRestaurantRes)(nil), "booking.ListUserRestaurantRes")
	proto.RegisterType((*ListUserAttractionRes)(nil), "booking.ListUserAttractionRes")
	proto.RegisterType((*GeneralBook)(nil), "booking.GeneralBook")
	proto.RegisterType((*UserId)(nil), "booking.UserId")
}

func init() { proto.RegisterFile("booking-proto/booking.proto", fileDescriptor_6f4ab27959496508) }

var fileDescriptor_6f4ab27959496508 = []byte{
	// 741 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x56, 0xdb, 0x6e, 0xd3, 0x4c,
	0x10, 0xfe, 0x9d, 0xb4, 0x4e, 0x33, 0x96, 0xd2, 0x68, 0xd5, 0xfe, 0x98, 0x56, 0x84, 0xc8, 0xe2,
	0x22, 0x5c, 0x50, 0xa4, 0x56, 0x22, 0x1c, 0xc4, 0x85, 0xdd, 0xd2, 0x26, 0x52, 0x25, 0xd0, 0x22,
	0x4b, 0xdc, 0x20, 0xcb, 0x8d, 0x37, 0xd4, 0xea, 0xd6, 0x0e, 0xeb, 0x75, 0x20, 0x6f, 0xc2, 0x23,
	0x71, 0x83, 0xc4, 0x13, 0x20, 0x54, 0x5e, 0x04, 0xed, 0x21, 0x69, 0x1c, 0xda, 0xe6, 0x70, 0x95,
	0xcc, 0x37, 0xf3, 0x7d, 0x33, 0x3b, 0x3b, 0xb3, 0x32, 0xec, 0x9e, 0xa5, 0xe9, 0x45, 0x9c, 0x7c,
	0x7a, 0x32, 0x60, 0x29, 0x4f, 0x9f, 0x6a, 0x6b, 0x4f, 0x5a, 0xa8, 0xa2, 0x4d, 0x67, 0x03, 0xcc,
	0x23, 0x42, 0x31, 0xc9, 0x9c, 0x2d, 0x28, 0x75, 0x23, 0x54, 0x83, 0x52, 0x1c, 0xd9, 0x46, 0xd3,
	0x68, 0x55, 0x71, 0x29, 0x8e, 0x9c, 0xaf, 0x60, 0x1e, 0xc7, 0x94, 0x13, 0x86, 0x0e, 0xc0, 0xec,
	0xcb, 0x7f, 0xb6, 0xd1, 0x2c, 0xb7, 0xac, 0xfd, 0xdd, 0xbd, 0xb1, 0xa4, 0x0a, 0xd0, 0x3f, 0x6f,
	0x12, 0xce, 0x46, 0x58, 0x87, 0xee, 0xbc, 0x00, 0x6b, 0x0a, 0x46, 0x75, 0x28, 0x5f, 0x90, 0x91,
	0x96, 0x17, 0x7f, 0xd1, 0x16, 0xac, 0x0f, 0x43, 0x9a, 0x13, 0xbb, 0x24, 0x31, 0x65, 0xbc, 0x2c,
	0x3d, 0x37, 0x9c, 0x0f, 0x60, 0x9d, 0xc6, 0x19, 0xc7, 0xe4, 0xb3, 0x37, 0xea, 0x46, 0x22, 0x90,
	0xc6, 0x97, 0x31, 0x97, 0xe4, 0x35, 0xac, 0x0c, 0xf4, 0x3f, 0x98, 0x69, 0xbf, 0x9f, 0x11, 0x2e,
	0xf9, 0x6b, 0x58, 0x5b, 0x68, 0x57, 0x1e, 0xa3, 0xdc, 0x34, 0x5a, 0xd6, 0xbe, 0x35, 0x29, 0xb4,
	0x1b, 0xc9, 0x33, 0xb5, 0xa1, 0xa2, 0x95, 0x97, 0x53, 0x75, 0x3e, 0x42, 0x5d, 0x10, 0xfd, 0x8c,
	0xb0, 0x4e, 0xca, 0x65, 0xdb, 0xd0, 0x01, 0x40, 0x9e, 0x11, 0x16, 0x9c, 0x0b, 0x40, 0xb7, 0x66,
	0x6b, 0x92, 0xf1, 0x84, 0x24, 0x84, 0x85, 0xd4, 0x4b, 0xd3, 0x0b, 0x5c, 0xcd, 0xc7, 0x3c, 0x91,
	0xb6, 0x97, 0xe6, 0x89, 0xd2, 0x2f, 0x63, 0x65, 0x38, 0x14, 0xb6, 0xc7, 0xf2, 0x98, 0x64, 0x3c,
	0xcc, 0x59, 0x98, 0x70, 0x91, 0xe3, 0x35, 0x6c, 0xca, 0x1c, 0x6c, 0x82, 0xde, 0x99, 0xa8, 0x96,
	0x17, 0x14, 0xe6, 0x67, 0x73, 0x39, 0x67, 0x61, 0x8f, 0xc7, 0x69, 0x32, 0x9d, 0x2d, 0x9c, 0xa0,
	0xf3, 0xb3, 0x5d, 0x2b, 0xdc, 0x92, 0xed, 0x47, 0x09, 0xac, 0x29, 0xd6, 0xec, 0x9c, 0xa1, 0x7b,
	0x50, 0x91, 0x49, 0xe3, 0x48, 0x4f, 0x82, 0x29, 0xcc, 0x6e, 0x84, 0xb6, 0xc1, 0x3c, 0x67, 0x61,
	0xa0, 0x6f, 0xb3, 0x8a, 0xd7, 0xcf, 0x59, 0xd8, 0x8d, 0xd0, 0x43, 0xb0, 0xbe, 0xc4, 0x94, 0x06,
	0x21, 0x63, 0xf1, 0x90, 0xd8, 0x6b, 0xd2, 0x07, 0x02, 0x72, 0x25, 0x82, 0x1e, 0x80, 0xb4, 0x02,
	0x4a, 0xc2, 0x21, 0xb1, 0xd7, 0xa5, 0xbf, 0x2a, 0x90, 0x53, 0x01, 0xa0, 0x16, 0xd4, 0x93, 0xfc,
	0xf2, 0x8c, 0xb0, 0x20, 0xed, 0x07, 0x03, 0x92, 0x0e, 0x28, 0xb1, 0x4d, 0x59, 0x70, 0x4d, 0xe1,
	0x6f, 0xfb, 0xef, 0x24, 0x2a, 0x32, 0xc5, 0x59, 0xd0, 0x0b, 0x93, 0x1e, 0xa1, 0x24, 0xb2, 0x2b,
	0x4d, 0xa3, 0xb5, 0x81, 0x21, 0xce, 0x0e, 0x35, 0x22, 0xa6, 0x85, 0x91, 0x30, 0x4b, 0x13, 0x7b,
	0x43, 0x55, 0xae, 0x2c, 0x51, 0x41, 0x8f, 0x91, 0x90, 0x93, 0x28, 0x08, 0xb9, 0x5d, 0x55, 0x15,
	0x68, 0xc4, 0xe5, 0xc2, 0x9d, 0x0f, 0xa2, 0xb1, 0x1b, 0x94, 0x5b, 0x23, 0xca, 0x1d, 0x11, 0x4a,
	0xb4, 0xdb, 0x52, 0x6e, 0x8d, 0xb8, 0xdc, 0x39, 0x02, 0xd3, 0x57, 0x0d, 0x7a, 0x74, 0xdd, 0x39,
	0x75, 0x4d, 0x85, 0x79, 0x1f, 0xb7, 0xf1, 0xc6, 0x5b, 0xd9, 0xff, 0x55, 0x85, 0x9a, 0xa7, 0x82,
	0xdf, 0x13, 0x36, 0x8c, 0x7b, 0x04, 0xb5, 0xa1, 0xea, 0x77, 0xbc, 0x43, 0x59, 0x26, 0xba, 0xf1,
	0xc6, 0x77, 0x6e, 0x44, 0x25, 0x11, 0xaf, 0x4a, 0x74, 0x57, 0x21, 0xba, 0x50, 0xf3, 0x3b, 0xde,
	0x09, 0xe1, 0x2e, 0xa5, 0xde, 0xc8, 0x17, 0xa7, 0x9c, 0xc4, 0x4d, 0x3d, 0x1d, 0x3b, 0xf7, 0x0b,
	0x68, 0x61, 0x7b, 0x8f, 0xa1, 0xe6, 0xe3, 0x05, 0x24, 0x1a, 0xff, 0x48, 0x14, 0x37, 0x54, 0xe8,
	0xb8, 0x2b, 0xe9, 0x14, 0x77, 0xaf, 0x5d, 0x38, 0x52, 0xe7, 0x56, 0x9d, 0xcd, 0x09, 0xaa, 0xa7,
	0xa0, 0x5d, 0x38, 0x08, 0x5e, 0x8e, 0x78, 0x5d, 0xb9, 0xbb, 0x38, 0xf1, 0x19, 0x54, 0xfc, 0x8e,
	0x27, 0x42, 0x50, 0x7d, 0x96, 0x71, 0x57, 0xcb, 0x5f, 0x41, 0xc5, 0xc7, 0xb7, 0xf1, 0xe6, 0xf5,
	0x59, 0x90, 0xdd, 0xc5, 0xc9, 0xb3, 0x0f, 0x5b, 0x4d, 0x57, 0x7c, 0xa4, 0xf6, 0x68, 0xb9, 0xc2,
	0x3d, 0xd9, 0xe2, 0xbb, 0xe9, 0xf3, 0xea, 0xf7, 0x64, 0xb7, 0x97, 0xd5, 0x98, 0x9d, 0x11, 0xb1,
	0xa1, 0xbe, 0x7c, 0x29, 0x56, 0xd8, 0xd0, 0x15, 0x89, 0xee, 0x2a, 0xc4, 0xc7, 0xb2, 0x54, 0x75,
	0x54, 0x34, 0xfd, 0x2e, 0x4d, 0x8d, 0x93, 0xfa, 0xfc, 0x90, 0xa1, 0x78, 0xf1, 0x50, 0x77, 0xa1,
	0x50, 0xaf, 0xfe, 0xfd, 0xaa, 0x61, 0xfc, 0xbc, 0x6a, 0x18, 0xbf, 0xaf, 0x1a, 0xc6, 0xb7, 0x3f,
	0x8d, 0xff, 0xce, 0x4c, 0xf9, 0x01, 0x74, 0xf0, 0x37, 0x00, 0x00, 0xff, 0xff, 0x68, 0x8b, 0x46,
	0x83, 0x1f, 0x09, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// BookingServiceClient is the client API for BookingService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type BookingServiceClient interface {
	UHBCreate(ctx context.Context, in *GeneralBook, opts ...grpc.CallOption) (*GeneralBook, error)
	URBCreate(ctx context.Context, in *GeneralBook, opts ...grpc.CallOption) (*GeneralBook, error)
	UABCreate(ctx context.Context, in *GeneralBook, opts ...grpc.CallOption) (*GeneralBook, error)
	UHBGetAllByUId(ctx context.Context, in *ListReqById, opts ...grpc.CallOption) (*ListUserHotelRes, error)
	URBGetAllByUId(ctx context.Context, in *ListReqById, opts ...grpc.CallOption) (*ListUserRestaurantRes, error)
	UABGetAllByUId(ctx context.Context, in *ListReqById, opts ...grpc.CallOption) (*ListUserAttractionRes, error)
	UHBGetAllByHId(ctx context.Context, in *ListReqById, opts ...grpc.CallOption) (*UserId, error)
	URBGetAllByRId(ctx context.Context, in *ListReqById, opts ...grpc.CallOption) (*UserId, error)
	UABGetAllByAId(ctx context.Context, in *ListReqById, opts ...grpc.CallOption) (*UserId, error)
	UHBList(ctx context.Context, in *ListReq, opts ...grpc.CallOption) (*ListUserHotelRes, error)
	URBList(ctx context.Context, in *ListReq, opts ...grpc.CallOption) (*ListUserRestaurantRes, error)
	UABList(ctx context.Context, in *ListReq, opts ...grpc.CallOption) (*ListUserAttractionRes, error)
	UHBListDeleted(ctx context.Context, in *ListReq, opts ...grpc.CallOption) (*ListUserHotelRes, error)
	URBListDeleted(ctx context.Context, in *ListReq, opts ...grpc.CallOption) (*ListUserRestaurantRes, error)
	UABListDeleted(ctx context.Context, in *ListReq, opts ...grpc.CallOption) (*ListUserAttractionRes, error)
	UHBUpdate(ctx context.Context, in *GeneralBook, opts ...grpc.CallOption) (*GeneralBook, error)
	URBUpdate(ctx context.Context, in *GeneralBook, opts ...grpc.CallOption) (*GeneralBook, error)
	UABUpdate(ctx context.Context, in *GeneralBook, opts ...grpc.CallOption) (*GeneralBook, error)
	UHBDelete(ctx context.Context, in *Id, opts ...grpc.CallOption) (*DelRes, error)
	URBDelete(ctx context.Context, in *Id, opts ...grpc.CallOption) (*DelRes, error)
	UABDelete(ctx context.Context, in *Id, opts ...grpc.CallOption) (*DelRes, error)
}

type bookingServiceClient struct {
	cc *grpc.ClientConn
}

func NewBookingServiceClient(cc *grpc.ClientConn) BookingServiceClient {
	return &bookingServiceClient{cc}
}

func (c *bookingServiceClient) UHBCreate(ctx context.Context, in *GeneralBook, opts ...grpc.CallOption) (*GeneralBook, error) {
	out := new(GeneralBook)
	err := c.cc.Invoke(ctx, "/booking.BookingService/UHBCreate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bookingServiceClient) URBCreate(ctx context.Context, in *GeneralBook, opts ...grpc.CallOption) (*GeneralBook, error) {
	out := new(GeneralBook)
	err := c.cc.Invoke(ctx, "/booking.BookingService/URBCreate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bookingServiceClient) UABCreate(ctx context.Context, in *GeneralBook, opts ...grpc.CallOption) (*GeneralBook, error) {
	out := new(GeneralBook)
	err := c.cc.Invoke(ctx, "/booking.BookingService/UABCreate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bookingServiceClient) UHBGetAllByUId(ctx context.Context, in *ListReqById, opts ...grpc.CallOption) (*ListUserHotelRes, error) {
	out := new(ListUserHotelRes)
	err := c.cc.Invoke(ctx, "/booking.BookingService/UHBGetAllByUId", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bookingServiceClient) URBGetAllByUId(ctx context.Context, in *ListReqById, opts ...grpc.CallOption) (*ListUserRestaurantRes, error) {
	out := new(ListUserRestaurantRes)
	err := c.cc.Invoke(ctx, "/booking.BookingService/URBGetAllByUId", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bookingServiceClient) UABGetAllByUId(ctx context.Context, in *ListReqById, opts ...grpc.CallOption) (*ListUserAttractionRes, error) {
	out := new(ListUserAttractionRes)
	err := c.cc.Invoke(ctx, "/booking.BookingService/UABGetAllByUId", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bookingServiceClient) UHBGetAllByHId(ctx context.Context, in *ListReqById, opts ...grpc.CallOption) (*UserId, error) {
	out := new(UserId)
	err := c.cc.Invoke(ctx, "/booking.BookingService/UHBGetAllByHId", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bookingServiceClient) URBGetAllByRId(ctx context.Context, in *ListReqById, opts ...grpc.CallOption) (*UserId, error) {
	out := new(UserId)
	err := c.cc.Invoke(ctx, "/booking.BookingService/URBGetAllByRId", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bookingServiceClient) UABGetAllByAId(ctx context.Context, in *ListReqById, opts ...grpc.CallOption) (*UserId, error) {
	out := new(UserId)
	err := c.cc.Invoke(ctx, "/booking.BookingService/UABGetAllByAId", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bookingServiceClient) UHBList(ctx context.Context, in *ListReq, opts ...grpc.CallOption) (*ListUserHotelRes, error) {
	out := new(ListUserHotelRes)
	err := c.cc.Invoke(ctx, "/booking.BookingService/UHBList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bookingServiceClient) URBList(ctx context.Context, in *ListReq, opts ...grpc.CallOption) (*ListUserRestaurantRes, error) {
	out := new(ListUserRestaurantRes)
	err := c.cc.Invoke(ctx, "/booking.BookingService/URBList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bookingServiceClient) UABList(ctx context.Context, in *ListReq, opts ...grpc.CallOption) (*ListUserAttractionRes, error) {
	out := new(ListUserAttractionRes)
	err := c.cc.Invoke(ctx, "/booking.BookingService/UABList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bookingServiceClient) UHBListDeleted(ctx context.Context, in *ListReq, opts ...grpc.CallOption) (*ListUserHotelRes, error) {
	out := new(ListUserHotelRes)
	err := c.cc.Invoke(ctx, "/booking.BookingService/UHBListDeleted", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bookingServiceClient) URBListDeleted(ctx context.Context, in *ListReq, opts ...grpc.CallOption) (*ListUserRestaurantRes, error) {
	out := new(ListUserRestaurantRes)
	err := c.cc.Invoke(ctx, "/booking.BookingService/URBListDeleted", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bookingServiceClient) UABListDeleted(ctx context.Context, in *ListReq, opts ...grpc.CallOption) (*ListUserAttractionRes, error) {
	out := new(ListUserAttractionRes)
	err := c.cc.Invoke(ctx, "/booking.BookingService/UABListDeleted", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bookingServiceClient) UHBUpdate(ctx context.Context, in *GeneralBook, opts ...grpc.CallOption) (*GeneralBook, error) {
	out := new(GeneralBook)
	err := c.cc.Invoke(ctx, "/booking.BookingService/UHBUpdate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bookingServiceClient) URBUpdate(ctx context.Context, in *GeneralBook, opts ...grpc.CallOption) (*GeneralBook, error) {
	out := new(GeneralBook)
	err := c.cc.Invoke(ctx, "/booking.BookingService/URBUpdate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bookingServiceClient) UABUpdate(ctx context.Context, in *GeneralBook, opts ...grpc.CallOption) (*GeneralBook, error) {
	out := new(GeneralBook)
	err := c.cc.Invoke(ctx, "/booking.BookingService/UABUpdate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bookingServiceClient) UHBDelete(ctx context.Context, in *Id, opts ...grpc.CallOption) (*DelRes, error) {
	out := new(DelRes)
	err := c.cc.Invoke(ctx, "/booking.BookingService/UHBDelete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bookingServiceClient) URBDelete(ctx context.Context, in *Id, opts ...grpc.CallOption) (*DelRes, error) {
	out := new(DelRes)
	err := c.cc.Invoke(ctx, "/booking.BookingService/URBDelete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bookingServiceClient) UABDelete(ctx context.Context, in *Id, opts ...grpc.CallOption) (*DelRes, error) {
	out := new(DelRes)
	err := c.cc.Invoke(ctx, "/booking.BookingService/UABDelete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// BookingServiceServer is the server API for BookingService service.
type BookingServiceServer interface {
	UHBCreate(context.Context, *GeneralBook) (*GeneralBook, error)
	URBCreate(context.Context, *GeneralBook) (*GeneralBook, error)
	UABCreate(context.Context, *GeneralBook) (*GeneralBook, error)
	UHBGetAllByUId(context.Context, *ListReqById) (*ListUserHotelRes, error)
	URBGetAllByUId(context.Context, *ListReqById) (*ListUserRestaurantRes, error)
	UABGetAllByUId(context.Context, *ListReqById) (*ListUserAttractionRes, error)
	UHBGetAllByHId(context.Context, *ListReqById) (*UserId, error)
	URBGetAllByRId(context.Context, *ListReqById) (*UserId, error)
	UABGetAllByAId(context.Context, *ListReqById) (*UserId, error)
	UHBList(context.Context, *ListReq) (*ListUserHotelRes, error)
	URBList(context.Context, *ListReq) (*ListUserRestaurantRes, error)
	UABList(context.Context, *ListReq) (*ListUserAttractionRes, error)
	UHBListDeleted(context.Context, *ListReq) (*ListUserHotelRes, error)
	URBListDeleted(context.Context, *ListReq) (*ListUserRestaurantRes, error)
	UABListDeleted(context.Context, *ListReq) (*ListUserAttractionRes, error)
	UHBUpdate(context.Context, *GeneralBook) (*GeneralBook, error)
	URBUpdate(context.Context, *GeneralBook) (*GeneralBook, error)
	UABUpdate(context.Context, *GeneralBook) (*GeneralBook, error)
	UHBDelete(context.Context, *Id) (*DelRes, error)
	URBDelete(context.Context, *Id) (*DelRes, error)
	UABDelete(context.Context, *Id) (*DelRes, error)
}

// UnimplementedBookingServiceServer can be embedded to have forward compatible implementations.
type UnimplementedBookingServiceServer struct {
}

func (*UnimplementedBookingServiceServer) UHBCreate(ctx context.Context, req *GeneralBook) (*GeneralBook, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UHBCreate not implemented")
}
func (*UnimplementedBookingServiceServer) URBCreate(ctx context.Context, req *GeneralBook) (*GeneralBook, error) {
	return nil, status.Errorf(codes.Unimplemented, "method URBCreate not implemented")
}
func (*UnimplementedBookingServiceServer) UABCreate(ctx context.Context, req *GeneralBook) (*GeneralBook, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UABCreate not implemented")
}
func (*UnimplementedBookingServiceServer) UHBGetAllByUId(ctx context.Context, req *ListReqById) (*ListUserHotelRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UHBGetAllByUId not implemented")
}
func (*UnimplementedBookingServiceServer) URBGetAllByUId(ctx context.Context, req *ListReqById) (*ListUserRestaurantRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method URBGetAllByUId not implemented")
}
func (*UnimplementedBookingServiceServer) UABGetAllByUId(ctx context.Context, req *ListReqById) (*ListUserAttractionRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UABGetAllByUId not implemented")
}
func (*UnimplementedBookingServiceServer) UHBGetAllByHId(ctx context.Context, req *ListReqById) (*UserId, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UHBGetAllByHId not implemented")
}
func (*UnimplementedBookingServiceServer) URBGetAllByRId(ctx context.Context, req *ListReqById) (*UserId, error) {
	return nil, status.Errorf(codes.Unimplemented, "method URBGetAllByRId not implemented")
}
func (*UnimplementedBookingServiceServer) UABGetAllByAId(ctx context.Context, req *ListReqById) (*UserId, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UABGetAllByAId not implemented")
}
func (*UnimplementedBookingServiceServer) UHBList(ctx context.Context, req *ListReq) (*ListUserHotelRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UHBList not implemented")
}
func (*UnimplementedBookingServiceServer) URBList(ctx context.Context, req *ListReq) (*ListUserRestaurantRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method URBList not implemented")
}
func (*UnimplementedBookingServiceServer) UABList(ctx context.Context, req *ListReq) (*ListUserAttractionRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UABList not implemented")
}
func (*UnimplementedBookingServiceServer) UHBListDeleted(ctx context.Context, req *ListReq) (*ListUserHotelRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UHBListDeleted not implemented")
}
func (*UnimplementedBookingServiceServer) URBListDeleted(ctx context.Context, req *ListReq) (*ListUserRestaurantRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method URBListDeleted not implemented")
}
func (*UnimplementedBookingServiceServer) UABListDeleted(ctx context.Context, req *ListReq) (*ListUserAttractionRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UABListDeleted not implemented")
}
func (*UnimplementedBookingServiceServer) UHBUpdate(ctx context.Context, req *GeneralBook) (*GeneralBook, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UHBUpdate not implemented")
}
func (*UnimplementedBookingServiceServer) URBUpdate(ctx context.Context, req *GeneralBook) (*GeneralBook, error) {
	return nil, status.Errorf(codes.Unimplemented, "method URBUpdate not implemented")
}
func (*UnimplementedBookingServiceServer) UABUpdate(ctx context.Context, req *GeneralBook) (*GeneralBook, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UABUpdate not implemented")
}
func (*UnimplementedBookingServiceServer) UHBDelete(ctx context.Context, req *Id) (*DelRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UHBDelete not implemented")
}
func (*UnimplementedBookingServiceServer) URBDelete(ctx context.Context, req *Id) (*DelRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method URBDelete not implemented")
}
func (*UnimplementedBookingServiceServer) UABDelete(ctx context.Context, req *Id) (*DelRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UABDelete not implemented")
}

func RegisterBookingServiceServer(s *grpc.Server, srv BookingServiceServer) {
	s.RegisterService(&_BookingService_serviceDesc, srv)
}

func _BookingService_UHBCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GeneralBook)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BookingServiceServer).UHBCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/booking.BookingService/UHBCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BookingServiceServer).UHBCreate(ctx, req.(*GeneralBook))
	}
	return interceptor(ctx, in, info, handler)
}

func _BookingService_URBCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GeneralBook)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BookingServiceServer).URBCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/booking.BookingService/URBCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BookingServiceServer).URBCreate(ctx, req.(*GeneralBook))
	}
	return interceptor(ctx, in, info, handler)
}

func _BookingService_UABCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GeneralBook)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BookingServiceServer).UABCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/booking.BookingService/UABCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BookingServiceServer).UABCreate(ctx, req.(*GeneralBook))
	}
	return interceptor(ctx, in, info, handler)
}

func _BookingService_UHBGetAllByUId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListReqById)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BookingServiceServer).UHBGetAllByUId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/booking.BookingService/UHBGetAllByUId",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BookingServiceServer).UHBGetAllByUId(ctx, req.(*ListReqById))
	}
	return interceptor(ctx, in, info, handler)
}

func _BookingService_URBGetAllByUId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListReqById)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BookingServiceServer).URBGetAllByUId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/booking.BookingService/URBGetAllByUId",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BookingServiceServer).URBGetAllByUId(ctx, req.(*ListReqById))
	}
	return interceptor(ctx, in, info, handler)
}

func _BookingService_UABGetAllByUId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListReqById)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BookingServiceServer).UABGetAllByUId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/booking.BookingService/UABGetAllByUId",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BookingServiceServer).UABGetAllByUId(ctx, req.(*ListReqById))
	}
	return interceptor(ctx, in, info, handler)
}

func _BookingService_UHBGetAllByHId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListReqById)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BookingServiceServer).UHBGetAllByHId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/booking.BookingService/UHBGetAllByHId",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BookingServiceServer).UHBGetAllByHId(ctx, req.(*ListReqById))
	}
	return interceptor(ctx, in, info, handler)
}

func _BookingService_URBGetAllByRId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListReqById)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BookingServiceServer).URBGetAllByRId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/booking.BookingService/URBGetAllByRId",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BookingServiceServer).URBGetAllByRId(ctx, req.(*ListReqById))
	}
	return interceptor(ctx, in, info, handler)
}

func _BookingService_UABGetAllByAId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListReqById)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BookingServiceServer).UABGetAllByAId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/booking.BookingService/UABGetAllByAId",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BookingServiceServer).UABGetAllByAId(ctx, req.(*ListReqById))
	}
	return interceptor(ctx, in, info, handler)
}

func _BookingService_UHBList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BookingServiceServer).UHBList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/booking.BookingService/UHBList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BookingServiceServer).UHBList(ctx, req.(*ListReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _BookingService_URBList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BookingServiceServer).URBList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/booking.BookingService/URBList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BookingServiceServer).URBList(ctx, req.(*ListReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _BookingService_UABList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BookingServiceServer).UABList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/booking.BookingService/UABList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BookingServiceServer).UABList(ctx, req.(*ListReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _BookingService_UHBListDeleted_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BookingServiceServer).UHBListDeleted(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/booking.BookingService/UHBListDeleted",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BookingServiceServer).UHBListDeleted(ctx, req.(*ListReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _BookingService_URBListDeleted_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BookingServiceServer).URBListDeleted(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/booking.BookingService/URBListDeleted",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BookingServiceServer).URBListDeleted(ctx, req.(*ListReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _BookingService_UABListDeleted_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BookingServiceServer).UABListDeleted(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/booking.BookingService/UABListDeleted",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BookingServiceServer).UABListDeleted(ctx, req.(*ListReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _BookingService_UHBUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GeneralBook)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BookingServiceServer).UHBUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/booking.BookingService/UHBUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BookingServiceServer).UHBUpdate(ctx, req.(*GeneralBook))
	}
	return interceptor(ctx, in, info, handler)
}

func _BookingService_URBUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GeneralBook)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BookingServiceServer).URBUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/booking.BookingService/URBUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BookingServiceServer).URBUpdate(ctx, req.(*GeneralBook))
	}
	return interceptor(ctx, in, info, handler)
}

func _BookingService_UABUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GeneralBook)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BookingServiceServer).UABUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/booking.BookingService/UABUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BookingServiceServer).UABUpdate(ctx, req.(*GeneralBook))
	}
	return interceptor(ctx, in, info, handler)
}

func _BookingService_UHBDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BookingServiceServer).UHBDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/booking.BookingService/UHBDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BookingServiceServer).UHBDelete(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _BookingService_URBDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BookingServiceServer).URBDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/booking.BookingService/URBDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BookingServiceServer).URBDelete(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _BookingService_UABDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BookingServiceServer).UABDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/booking.BookingService/UABDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BookingServiceServer).UABDelete(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

var _BookingService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "booking.BookingService",
	HandlerType: (*BookingServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "UHBCreate",
			Handler:    _BookingService_UHBCreate_Handler,
		},
		{
			MethodName: "URBCreate",
			Handler:    _BookingService_URBCreate_Handler,
		},
		{
			MethodName: "UABCreate",
			Handler:    _BookingService_UABCreate_Handler,
		},
		{
			MethodName: "UHBGetAllByUId",
			Handler:    _BookingService_UHBGetAllByUId_Handler,
		},
		{
			MethodName: "URBGetAllByUId",
			Handler:    _BookingService_URBGetAllByUId_Handler,
		},
		{
			MethodName: "UABGetAllByUId",
			Handler:    _BookingService_UABGetAllByUId_Handler,
		},
		{
			MethodName: "UHBGetAllByHId",
			Handler:    _BookingService_UHBGetAllByHId_Handler,
		},
		{
			MethodName: "URBGetAllByRId",
			Handler:    _BookingService_URBGetAllByRId_Handler,
		},
		{
			MethodName: "UABGetAllByAId",
			Handler:    _BookingService_UABGetAllByAId_Handler,
		},
		{
			MethodName: "UHBList",
			Handler:    _BookingService_UHBList_Handler,
		},
		{
			MethodName: "URBList",
			Handler:    _BookingService_URBList_Handler,
		},
		{
			MethodName: "UABList",
			Handler:    _BookingService_UABList_Handler,
		},
		{
			MethodName: "UHBListDeleted",
			Handler:    _BookingService_UHBListDeleted_Handler,
		},
		{
			MethodName: "URBListDeleted",
			Handler:    _BookingService_URBListDeleted_Handler,
		},
		{
			MethodName: "UABListDeleted",
			Handler:    _BookingService_UABListDeleted_Handler,
		},
		{
			MethodName: "UHBUpdate",
			Handler:    _BookingService_UHBUpdate_Handler,
		},
		{
			MethodName: "URBUpdate",
			Handler:    _BookingService_URBUpdate_Handler,
		},
		{
			MethodName: "UABUpdate",
			Handler:    _BookingService_UABUpdate_Handler,
		},
		{
			MethodName: "UHBDelete",
			Handler:    _BookingService_UHBDelete_Handler,
		},
		{
			MethodName: "URBDelete",
			Handler:    _BookingService_URBDelete_Handler,
		},
		{
			MethodName: "UABDelete",
			Handler:    _BookingService_UABDelete_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "booking-proto/booking.proto",
}

func (m *DelRes) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DelRes) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DelRes) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *Id) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Id) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Id) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintBooking(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Filter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Filter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Filter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Filter) > 0 {
		for k := range m.Filter {
			v := m.Filter[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintBooking(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintBooking(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintBooking(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ListReqById) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListReqById) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListReqById) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Id != nil {
		{
			size, err := m.Id.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBooking(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Offset != 0 {
		i = encodeVarintBooking(dAtA, i, uint64(m.Offset))
		i--
		dAtA[i] = 0x10
	}
	if m.Limit != 0 {
		i = encodeVarintBooking(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ListReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Offset != 0 {
		i = encodeVarintBooking(dAtA, i, uint64(m.Offset))
		i--
		dAtA[i] = 0x10
	}
	if m.Limit != 0 {
		i = encodeVarintBooking(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ListUserHotelRes) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListUserHotelRes) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListUserHotelRes) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Count != 0 {
		i = encodeVarintBooking(dAtA, i, uint64(m.Count))
		i--
		dAtA[i] = 0x10
	}
	if len(m.UserHotel) > 0 {
		for iNdEx := len(m.UserHotel) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.UserHotel[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBooking(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ListUserRestaurantRes) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListUserRestaurantRes) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListUserRestaurantRes) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Count != 0 {
		i = encodeVarintBooking(dAtA, i, uint64(m.Count))
		i--
		dAtA[i] = 0x10
	}
	if len(m.UserRestaurant) > 0 {
		for iNdEx := len(m.UserRestaurant) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.UserRestaurant[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBooking(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ListUserAttractionRes) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListUserAttractionRes) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListUserAttractionRes) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Count != 0 {
		i = encodeVarintBooking(dAtA, i, uint64(m.Count))
		i--
		dAtA[i] = 0x10
	}
	if len(m.UserAttraction) > 0 {
		for iNdEx := len(m.UserAttraction) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.UserAttraction[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBooking(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *GeneralBook) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GeneralBook) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GeneralBook) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.DeletedAt) > 0 {
		i -= len(m.DeletedAt)
		copy(dAtA[i:], m.DeletedAt)
		i = encodeVarintBooking(dAtA, i, uint64(len(m.DeletedAt)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.UpdatedAt) > 0 {
		i -= len(m.UpdatedAt)
		copy(dAtA[i:], m.UpdatedAt)
		i = encodeVarintBooking(dAtA, i, uint64(len(m.UpdatedAt)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.CreatedAt) > 0 {
		i -= len(m.CreatedAt)
		copy(dAtA[i:], m.CreatedAt)
		i = encodeVarintBooking(dAtA, i, uint64(len(m.CreatedAt)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintBooking(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x42
	}
	if m.IsCanceled {
		i--
		if m.IsCanceled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.NumberOfPeople != 0 {
		i = encodeVarintBooking(dAtA, i, uint64(m.NumberOfPeople))
		i--
		dAtA[i] = 0x30
	}
	if len(m.WillLeave) > 0 {
		i -= len(m.WillLeave)
		copy(dAtA[i:], m.WillLeave)
		i = encodeVarintBooking(dAtA, i, uint64(len(m.WillLeave)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.WillArrive) > 0 {
		i -= len(m.WillArrive)
		copy(dAtA[i:], m.WillArrive)
		i = encodeVarintBooking(dAtA, i, uint64(len(m.WillArrive)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.HraId) > 0 {
		i -= len(m.HraId)
		copy(dAtA[i:], m.HraId)
		i = encodeVarintBooking(dAtA, i, uint64(len(m.HraId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.UserId) > 0 {
		i -= len(m.UserId)
		copy(dAtA[i:], m.UserId)
		i = encodeVarintBooking(dAtA, i, uint64(len(m.UserId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintBooking(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UserId) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserId) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserId) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Count != 0 {
		i = encodeVarintBooking(dAtA, i, uint64(m.Count))
		i--
		dAtA[i] = 0x10
	}
	if len(m.UserId) > 0 {
		for iNdEx := len(m.UserId) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.UserId[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBooking(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintBooking(dAtA []byte, offset int, v uint64) int {
	offset -= sovBooking(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *DelRes) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Id) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovBooking(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Filter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Filter) > 0 {
		for k, v := range m.Filter {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovBooking(uint64(len(k))) + 1 + len(v) + sovBooking(uint64(len(v)))
			n += mapEntrySize + 1 + sovBooking(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListReqById) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Limit != 0 {
		n += 1 + sovBooking(uint64(m.Limit))
	}
	if m.Offset != 0 {
		n += 1 + sovBooking(uint64(m.Offset))
	}
	if m.Id != nil {
		l = m.Id.Size()
		n += 1 + l + sovBooking(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Limit != 0 {
		n += 1 + sovBooking(uint64(m.Limit))
	}
	if m.Offset != 0 {
		n += 1 + sovBooking(uint64(m.Offset))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListUserHotelRes) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.UserHotel) > 0 {
		for _, e := range m.UserHotel {
			l = e.Size()
			n += 1 + l + sovBooking(uint64(l))
		}
	}
	if m.Count != 0 {
		n += 1 + sovBooking(uint64(m.Count))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListUserRestaurantRes) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.UserRestaurant) > 0 {
		for _, e := range m.UserRestaurant {
			l = e.Size()
			n += 1 + l + sovBooking(uint64(l))
		}
	}
	if m.Count != 0 {
		n += 1 + sovBooking(uint64(m.Count))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListUserAttractionRes) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.UserAttraction) > 0 {
		for _, e := range m.UserAttraction {
			l = e.Size()
			n += 1 + l + sovBooking(uint64(l))
		}
	}
	if m.Count != 0 {
		n += 1 + sovBooking(uint64(m.Count))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GeneralBook) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovBooking(uint64(l))
	}
	l = len(m.UserId)
	if l > 0 {
		n += 1 + l + sovBooking(uint64(l))
	}
	l = len(m.HraId)
	if l > 0 {
		n += 1 + l + sovBooking(uint64(l))
	}
	l = len(m.WillArrive)
	if l > 0 {
		n += 1 + l + sovBooking(uint64(l))
	}
	l = len(m.WillLeave)
	if l > 0 {
		n += 1 + l + sovBooking(uint64(l))
	}
	if m.NumberOfPeople != 0 {
		n += 1 + sovBooking(uint64(m.NumberOfPeople))
	}
	if m.IsCanceled {
		n += 2
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovBooking(uint64(l))
	}
	l = len(m.CreatedAt)
	if l > 0 {
		n += 1 + l + sovBooking(uint64(l))
	}
	l = len(m.UpdatedAt)
	if l > 0 {
		n += 1 + l + sovBooking(uint64(l))
	}
	l = len(m.DeletedAt)
	if l > 0 {
		n += 1 + l + sovBooking(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UserId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.UserId) > 0 {
		for _, e := range m.UserId {
			l = e.Size()
			n += 1 + l + sovBooking(uint64(l))
		}
	}
	if m.Count != 0 {
		n += 1 + sovBooking(uint64(m.Count))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovBooking(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozBooking(x uint64) (n int) {
	return sovBooking(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *DelRes) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBooking
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DelRes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DelRes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipBooking(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBooking
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Id) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBooking
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Id: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Id: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBooking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBooking
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBooking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBooking(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBooking
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Filter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBooking
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Filter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Filter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBooking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBooking
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBooking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Filter == nil {
				m.Filter = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBooking
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBooking
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthBooking
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthBooking
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBooking
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthBooking
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthBooking
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipBooking(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthBooking
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Filter[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBooking(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBooking
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListReqById) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBooking
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListReqById: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListReqById: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBooking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			m.Offset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBooking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Offset |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBooking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBooking
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBooking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Id == nil {
				m.Id = &Id{}
			}
			if err := m.Id.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBooking(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBooking
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBooking
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBooking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			m.Offset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBooking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Offset |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBooking(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBooking
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListUserHotelRes) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBooking
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListUserHotelRes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListUserHotelRes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserHotel", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBooking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBooking
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBooking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserHotel = append(m.UserHotel, &GeneralBook{})
			if err := m.UserHotel[len(m.UserHotel)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBooking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBooking(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBooking
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListUserRestaurantRes) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBooking
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListUserRestaurantRes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListUserRestaurantRes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserRestaurant", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBooking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBooking
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBooking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserRestaurant = append(m.UserRestaurant, &GeneralBook{})
			if err := m.UserRestaurant[len(m.UserRestaurant)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBooking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBooking(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBooking
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListUserAttractionRes) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBooking
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListUserAttractionRes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListUserAttractionRes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserAttraction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBooking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBooking
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBooking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserAttraction = append(m.UserAttraction, &GeneralBook{})
			if err := m.UserAttraction[len(m.UserAttraction)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBooking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBooking(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBooking
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GeneralBook) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBooking
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GeneralBook: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GeneralBook: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBooking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBooking
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBooking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBooking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBooking
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBooking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HraId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBooking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBooking
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBooking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HraId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WillArrive", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBooking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBooking
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBooking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WillArrive = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WillLeave", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBooking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBooking
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBooking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WillLeave = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumberOfPeople", wireType)
			}
			m.NumberOfPeople = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBooking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumberOfPeople |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsCanceled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBooking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsCanceled = bool(v != 0)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBooking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBooking
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBooking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBooking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBooking
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBooking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreatedAt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBooking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBooking
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBooking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpdatedAt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeletedAt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBooking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBooking
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBooking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeletedAt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBooking(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBooking
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserId) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBooking
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserId: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserId: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBooking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBooking
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBooking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserId = append(m.UserId, &Id{})
			if err := m.UserId[len(m.UserId)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBooking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBooking(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBooking
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipBooking(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowBooking
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBooking
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBooking
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthBooking
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupBooking
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthBooking
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthBooking        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowBooking          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupBooking = fmt.Errorf("proto: unexpected end of group")
)
